/**
 * A list of regexes to match all types and subtypes generated by prisma for a specific
 * model
 */
export function createRegexForType(name: string) {
  return [
    // new RegExp(`^${name}CountAggregate$`, 'm'),
    // new RegExp(`^${name}CountAggregateOutputType$`, 'm'), `number` fields
    // new RegExp(`^${name}CountOrderByAggregateInput$`, 'm'), `SortOrder` fields
    // new RegExp(`^${name}CountAggregateInputType$`, 'm'), `true` fields

    // new RegExp(`^${name}Group$`, 'm'),
    // new RegExp(`^${name}GroupByOutputType$`, 'm'),
    // new RegExp(`^${name}OrderByWithRelationInput$`, 'm'), `SortOrder` fields
    // new RegExp(`^${name}OrderByWithAggregationInput$`, 'm'), `SortOrder` fields

    // new RegExp(`^${name}(?:Scalar)?Where$`, 'm'),
    // new RegExp(`^${name}(?:Scalar)?WhereInput$`, 'm'),
    // new RegExp(`^${name}(?:Scalar)?WhereWithAggregatesInput$`, 'm'),

    // new RegExp(`^${name}(?:Unchecked)?CreateInput$`, 'm'),
    // new RegExp(`^${name}(?:Unchecked)?CreateManyInput$`, 'm'),
    new RegExp(`^${name}(?:Unchecked)?CreateWithout(?:\\w+?)Input$`, 'm'),
    new RegExp(`^${name}(?:Unchecked)?CreateMany(?:\\w+?)Input$`, 'm'),

    // new RegExp(`^${name}(?:Unchecked)?UpdateInput$`, 'm'),
    // new RegExp(`^${name}(?:Unchecked)?UpdateManyInput$`, 'm'),
    // new RegExp(`^${name}(?:Unchecked)?UpdateManyMutationInput$`, 'm'),
    new RegExp(`^${name}(?:Unchecked)?UpdateWithout(?:\\w+?)Input$`, 'm'),
    new RegExp(`^${name}(?:Unchecked)?UpdateManyWithout(?:\\w+?)Input$`, 'm')
  ];
}

export function extractBaseNameFromRelationType(typeName: string): string | null {
  const createWithoutRegex = /^(.+?)(?:Unchecked)?CreateWithout(?:\w+?)Input$/m;
  const createManyRegex = /^(.+?)(?:Unchecked)?CreateMany(?:\w+?)Input$/m;
  const updateWithoutRegex = /^(.+?)(?:Unchecked)?UpdateWithout(?:\w+?)Input$/m;
  const updateManyWithoutRegex = /^(.+?)(?:Unchecked)?UpdateManyWithout(?:\w+?)Input$/m;

  let match = typeName.match(createWithoutRegex);
  if (match?.[1]) {
    return match[1];
  }

  match = typeName.match(createManyRegex);
  if (match?.[1]) {
    return match[1];
  }

  match = typeName.match(updateWithoutRegex);
  if (match?.[1]) {
    return match[1];
  }

  match = typeName.match(updateManyWithoutRegex);
  if (match?.[1]) {
    return match[1];
  }

  return null;
}

/** If the provided type is a update one variant */
export function isUpdateOneType(type: string) {
  return (
    type.match(/UpdateInput$/m) ||
    type.match(/UpdateWithout(?:\w+?)Input$/m) ||
    type.match(/UpdateManyWithout(?:\w+?)Input$/m)
  );
}

/**
 * Generates a list of potential type names based on the regex patterns
 * used in `createRegexForType`. Note that types involving relation names
 * (e.g., `CreateWithout[Relation]Input`) are not generated by this function.
 *
 * @param name The base name (e.g., model name)
 * @returns An array of generated type names
 */
export function generateTypeNamesFromName(name: string): string[] {
  const types: string[] = [];

  types.push(`$${name}Payload`);

  // CountAggregate
  types.push(`${name}CountAggregate`);

  // GroupBy
  types.push(`${name}Group`);
  types.push(`${name}GroupByOutputType`);

  // Where types
  types.push(`${name}Where`, `${name}ScalarWhere`);
  types.push(`${name}WhereInput`, `${name}ScalarWhereInput`);
  types.push(`${name}WhereWithAggregatesInput`, `${name}ScalarWhereWithAggregatesInput`);

  // Create types (excluding relation-specific ones)
  types.push(`${name}CreateInput`, `${name}UncheckedCreateInput`);
  types.push(`${name}CreateManyInput`, `${name}UncheckedCreateManyInput`);

  // Update types (excluding relation-specific ones)
  types.push(`${name}UpdateInput`, `${name}UncheckedUpdateInput`);
  types.push(`${name}UpdateManyInput`, `${name}UncheckedUpdateManyInput`);
  types.push(`${name}UpdateManyMutationInput`, `${name}UncheckedUpdateManyMutationInput`);

  return types;
}
